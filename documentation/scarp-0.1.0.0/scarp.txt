-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Stochastic Revealed Preferences module for the Collective Random Utility Model
--   
--   Please see README.md
@package scarp
@version 0.1.0.0

module Helpers

-- | Basic choices
type BinRel = Matrix Bool
newtype IChoice
IChoice :: [Double] -> IChoice
[repr] :: IChoice -> [Double]
type HChoice3 = (IChoice, IChoice, IChoice)
type HChoice4 = (IChoice, IChoice, IChoice, IChoice)

-- | Classified (rational/irrational) choice per period
type RChoice = (HChoice3, Bool, Int)
type Paths = [([HChoice3], Bool, [Int])]
fst3 :: (a, b, c) -> a
snd3 :: (a, b, c) -> b
trd3 :: (a, b, c) -> c
class Tuplifyable c e
tuplify :: Tuplifyable c e => [e] -> c
class MapableTuple c e
tmap :: MapableTuple c e => (e -> e) -> c -> c
tuplify2 :: [a] -> (a, a)
dot' :: [Double] -> [Double] -> Double
encodeOrd :: Ordering -> Double
boolToDouble :: Bool -> Double
compareFloat :: Double -> Double -> Ordering
histogram :: (Ord a, Eq a) => [a] -> [a] -> [(a, Int)]
safeHistogram :: (Ord a, Eq a) => [a] -> [a] -> [(a, Int)]
instance GHC.Generics.Generic Helpers.IChoice
instance GHC.Read.Read Helpers.IChoice
instance GHC.Classes.Ord Helpers.IChoice
instance GHC.Classes.Eq Helpers.IChoice
instance Helpers.MapableTuple (Helpers.BinRel, Helpers.BinRel, Helpers.BinRel) Helpers.BinRel
instance Helpers.MapableTuple (Helpers.HChoice3, Helpers.HChoice3, Helpers.HChoice3) Helpers.HChoice3
instance Helpers.MapableTuple (Helpers.BinRel, Helpers.BinRel, Helpers.BinRel, Helpers.BinRel) Helpers.BinRel
instance Helpers.Tuplifyable Helpers.HChoice3 Helpers.IChoice
instance Helpers.Tuplifyable Helpers.HChoice4 Helpers.IChoice
instance Control.DeepSeq.NFData Helpers.IChoice
instance GHC.Show.Show Helpers.IChoice

module Encode

-- | Check if consumption x is affordable under price regime p
checkConsumption :: [Double] -> [Double] -> Double

-- | Constructs choice path of one individual: periods (outer), encoded
--   polyhedra (inner) | inner part refers to feasibility
--   (checkConsumption) of choice in period t (outer) | when budget set
--   would be s (inner) | rows == cols and zero diagonal by construction
encodeConsumption :: [[Double]] -> [[Double]] -> [[Double]]

-- | Takes a vector of vectors of consumptions representing each member in
--   the group (outer) | and constructions a path of encoded group
--   consumptions
encodeGroupConsumption :: [[Double]] -> [[[Double]]] -> [[[Double]]]

-- | Returns all possible combinations of choices on in | Level 0
--   (outermost): periods | Level 1: choice set for household in respective
--   period | Level 2: particular choice of household | Level 3
--   (innermost): choice per individual (polyhedra)
choicesPerPeriod :: Int -> [[[IChoice]]]
combinations :: Int -> [[[IChoice]]]
combinationsPeriod :: Int -> Int -> [[IChoice]]
choicesPerComposition :: Int -> [[[IChoice]]]

-- | Takes list of period choices and constructs all resulting choice
--   combinations | [[]] is unit-element of operation <a>*</a> on list
--   applicative functor | Each element is one choice path | depr
combinePeriods :: [[a]] -> [[a]]

-- | Constructs a forest from decision space and crawles the branches to
--   check rationality | once an irrational branch is found, the
--   rationality of all child branches is set to false | one-elements
--   (start with): makeDecisionForest [] True choicespace
makeDecisionForest :: ([HChoice3] -> Bool) -> [HChoice3] -> Bool -> [[[IChoice]]] -> Forest RChoice
forestToChoicespace :: Forest RChoice -> [RChoice]
paths :: Tree a -> [[a]]
classifyPaths :: Forest (HChoice3, Bool, Int) -> Paths
asAssocMatrix :: Forest (HChoice3, Bool, Int) -> [Int] -> AssocMatrix
trAssocMatrix :: AssocMatrix -> AssocMatrix

-- | Histogram uses a little (dirty) trick to also count empty categories:
--   first add one of each index, then decrease all length by one
--   asSparseVector :: [[HChoice3]] -&gt; [[RChoice]] -&gt; GMatrix
--   asSparseVector a b = mkSparse $ asAssocVector a b
--   
--   depr asAssocVector :: [[HChoice3]] -&gt; [[RChoice]] -&gt; AssocMatrix
--   asAssocVector sampledPaths choicesPerPeriod = histogram where
--   histogram = [((head l, 0), fromIntegral (length l - 1) / fromIntegral
--   (length sampledPaths)) | l &lt;- group (sort $ indices ++
--   [0..(nChoicesPerPeriod*periods-1)])] nChoicesPerPeriod = (head . map
--   length) choicesPerPeriod periods = length choicesPerPeriod indices =
--   join $ map (zipWith (offset x -&gt; offset x) (offsetters
--   nChoicesPerPeriod)) indices' indices' = fromJust $ mapM (sequence .
--   (sp -&gt; zipWith (curry lookForIndex) sp choicesPerPeriod))
--   sampledPaths
--   
--   |depr combinations :: Int -&gt; [[[[Double]]]] combinations p = map (t
--   -&gt; household t ++ members t) [0..(p-1)] -- not replicate3, first
--   one without zero then append where household t = replicateM 2 $ map
--   (squeeze (-1.0) t) powerset ++ map (squeeze 1.0 t) powerset members t
--   = replicateM 2 (map (squeeze 0.0 t) powerset) squeeze d t c = take t c
--   ++ [d] ++ drop t c powerset = replicateM (p-1) [-1.0, 1.0]
asAssocMatrix' :: Int -> [Int] -> [[Int]] -> AssocMatrix
offsetters :: [Int] -> [Int -> Int]
getChoicesPerPeriod :: [Tree RChoice] -> [[RChoice]]
lookForIndex :: (HChoice3, [RChoice]) -> Maybe Int

module Continuous
data Index
Index :: String -> String -> Index
data Value
Value :: Double -> [Double] -> [Double] -> Value
data PQ
PQ :: Index -> Value -> PQ
byYear :: [PQ] -> String -> [PQ]
sampleSize :: [PQ] -> [Int]
reshapeToMatrices :: [PQ] -> (Vector Double, Matrix Double, Matrix Double)
getYears :: [PQ] -> [String]
encodeBudget :: [[Double]] -> [[Double]]
discretizeIndiv :: [PQ] -> String -> [[Double]]
discretizeCouple :: [PQ] -> String -> [[Double]]
perBudget :: Vector Double -> Matrix Double -> Matrix Double -> Vector Double
instance GHC.Show.Show Continuous.PQ
instance GHC.Show.Show Continuous.Value
instance GHC.Show.Show Continuous.Index

module NNLS
type StepInfoSparse = (Int, SparseVector Double)
type StepInfo = (Int, Vector Double)
stepLandweber :: Matrix Double -> Vector Double -> Vector Double -> StepInfo -> StepInfo
stepwiseOptimizer :: (StepInfo -> StepInfo) -> StepInfo -> StepInfo
fctJ :: Int -> Matrix Double -> Vector Double -> Vector Double -> Vector Double -> Double
stepLandweberSparse :: SparseMatrix Double -> SparseVector Double -> SparseVector Double -> StepInfoSparse -> StepInfoSparse
stepwiseOptimizerSparse :: (StepInfoSparse -> StepInfoSparse) -> StepInfoSparse -> StepInfoSparse
fctJSparse :: Int -> SparseMatrix Double -> SparseVector Double -> SparseVector Double -> Double

module Randomization
randomChoicePath :: PrimMonad m => [a] -> Maybe [Double] -> Gen (PrimState m) -> m a
discreteQuantile :: [Double] -> Double -> Int
randomChoicePath' :: PrimMonad m => [a] -> [a] -> Double -> Gen (PrimState m) -> m a
bootstrapIdcs :: PrimMonad m => [Int] -> Int -> Gen (PrimState m) -> m [[[Int]]]

module Settings
resultsPrefix :: String
dataPrefix :: String

module Dataset
priceData :: IO [((String, String), Double)]
prepareDataset :: [String] -> [String] -> IO [PQ]

module Warshall
warshall :: Int -> Int -> BinRel -> Bool
adjacent :: (Int, Int, Int) -> BinRel -> Bool
constructPath :: (Int, Int, Int) -> BinRel -> [Int]
testAdjacencyMatrix :: [[Bool]]
transitiveClosure :: BinRel -> BinRel

module CollectiveAxiom

-- | only a test function
checkAllEqual :: (Eq a, Ord a, Show a, Num a) => [HChoice3] -> HChoice3 -> Bool
checkCollectiveRationality :: (Eq a, Ord a, Show a, Num a) => [HChoice3] -> Bool

-- | makes graphs representing R0's for each member | e.g. (h0p1 = -1
--   <a>=</a> h0p1 <a>= 1) =</a> h1 R h0
makeGraphs :: (Eq a, Num a) => [HChoice3] -> (BinRel, BinRel, BinRel, BinRel)
allElements :: BinRel -> Bool
anyElement :: BinRel -> Bool

-- | Returns indices columns of the preference relation matrix which puts a
--   restriction on the individuals
restrictionsFromSum :: BinRel -> [Int]
takeCols :: [Int] -> BinRel -> BinRel
checkI :: BinRel -> BinRel -> BinRel -> BinRel -> BinRel -> BinRel -> BinRel -> Bool
checkIII :: BinRel -> BinRel -> BinRel -> BinRel -> BinRel -> BinRel -> BinRel -> Bool

-- | Logic: remove all rows for which there are no restrictions from sum
--   (if zero rows remain - immediately conclude rational: null js)
checkIV :: BinRel -> BinRel -> BinRel -> BinRel -> BinRel -> BinRel -> BinRel -> Bool

-- | logic: if in a any row of the or-ed pref rels, all elements are true
--   than this is violated
checkV :: BinRel -> BinRel -> BinRel -> BinRel -> BinRel -> BinRel -> BinRel -> Bool
checkVI :: BinRel -> BinRel -> BinRel -> BinRel -> BinRel -> BinRel -> BinRel -> Bool
checkIndividualRationality :: (Eq a, Ord a, Show a, Num a) => HChoice3 -> Bool

-- | this was for the household data
checkPathIndividualRationality :: (Eq a, Ord a, Show a, Num a) => [HChoice3] -> Bool

module Discretization
nPeriods :: Int
classifyTree :: [([HChoice3], [Int])] -> [([HChoice3], [Int], (Bool, Bool))]
cpp :: [[HChoice3]]
pickleTypeSpace :: FilePath -> AssocMatrix -> IO ()
unpickleTypeSpace :: FilePath -> IO AssocMatrix
getChoicePiResampler :: [[HChoice3]] -> [[Int]] -> [[HChoice3]] -> SparseVector Double
reshuffleChoices :: [[HChoice3]] -> [[Int]] -> [[HChoice3]]
getPiFromChoices :: [[HChoice3]] -> SparseVector Double

module Test
type PiResampler = [[Int]] -> [[HChoice3]] -> SparseVector Double
maxSteps :: Int
calculateTestStatistic :: Maybe Double -> SparseMatrix Double -> PiResampler -> [[[Int]]] -> [[HChoice3]] -> (Double, [Double], Int, [Int])
dataTau :: Int -> SparseMatrix Double -> SparseVector Double -> Maybe Double -> Maybe (SparseVector Double)
writeEmpDist :: Int -> Int -> Double -> [Double] -> IO ()

module Simulation
classifiedPaths :: [([HChoice3], [Int], (Bool, Bool))]
collectiveFilter :: ([HChoice3], [Int], (Bool, Bool)) -> Bool
noncoorpFilter :: ([HChoice3], [Int], (Bool, Bool)) -> Bool
irrationalFilter :: ([HChoice3], [Int], (Bool, Bool)) -> Bool

-- | Paths that are consistent with the aggregate restrictions based on
--   Cherchye et al, not using singles | Only heads are considered, this
--   should be done with [path, [], []] for non-path couple observations
weakCollectiveFilter :: [[HChoice3]] -> ([HChoice3], [Int], (Bool, Bool)) -> Bool
possibleFromAggregate :: [[HChoice3]] -> [HChoice3]
rationalPathsAndIndices :: ([[HChoice3]], [[Int]])
generateChoices :: PrimMonad m => Int -> Int -> Double -> Maybe (Int, [Double]) -> Gen (PrimState m) -> m (SparseMatrix Double, [[[HChoice3]]])
worstCases :: [[HChoice3]] -> [[[HChoice3]]] -> [[[HChoice3]]]
pickleResults :: FilePath -> [((Int, Double, Maybe (Int, [Double])), ([Double], [Double]))] -> IO ()
unpickleResults :: FilePath -> IO [((Int, Double, Maybe (Int, [Double])), ([Double], [Double]))]
simulationPerPN :: Int -> Int -> Int -> Double -> Maybe (Int, [Double]) -> Maybe Double -> IO ([Double], [Double])
resumeSimulation :: Int -> Int -> FilePath -> (Int -> Int) -> Maybe (Int, [Double]) -> Maybe Double -> Int -> Double -> IO ([Double], [Double])
plotPower :: String -> FilePath -> Int -> IO ()
plotSize :: String -> FilePath -> Int -> IO ()

module Empirical
encodeDataset :: [HChoice3] -> [PQ] -> ([HChoice3], [HChoice3], [[Int]])
empiricalByDataset :: SparseMatrix Double -> [HChoice3] -> [PQ] -> IO (Double, [[Int]])
pickleEmpirical :: FilePath -> [([String], (Double, [[Int]]))] -> IO ()
unpickleEmpirical :: FilePath -> IO [([String], (Double, [[Int]]))]
resumeEmpirical :: FilePath -> [String] -> SparseMatrix Double -> [HChoice3] -> [PQ] -> IO ([String], (Double, [[Int]]))
writeTable :: FilePath -> [([String], (Double, [[Int]]))] -> IO ()
